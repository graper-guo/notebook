# **【PHP源码学习】2019-03-13 PHP字符串笔记**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/7404d5327e095ee48529da5b5ea9a73d.flv.mp4

## malloc函数深入
 - 在[PHP内存管理1笔记](https://segmentfault.com/a/1190000018909215)中提到，malloc()函数会在分配的内存空间前面额外分配32位，用来存储分配的大小和几个标志位，如图：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/23/1556011070035.png)
 - 那么究竟是否是这样的呢？我们写一段测试代码验证一下：
```c
#include <stdlib.h>
int main() {
    void *ptr = malloc(8);
    return 1;
}
```
 - 利用gdb调试这段代码：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/23/1556011536132.png)
 - 首先打印ptr的地址，为0x602010，利用x命令往后看20个内存单元（1个内存单元 = 4个字节），故一共展示了80个字节，后面的x是以16进制打印内容。
 - 我们发现紧邻0x602010地址的上面32位均是0，没有任何内容，不符合我们的预期。
 - 上图只是一个最简单的思路，但绝大多数操作系统是按照如下的方式实现的：

>操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
   malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表（Free List）。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块(根据不同的算法而定（将最先找到的不小于申请的大小内存块分配给请求者，将最合适申请大小的空闲内存分配给请求者，或者是分配最大的空闲块内存块）。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。
   调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。

## 结构体与联合体复习
### 结构体
 - 在[PHP内存管理2笔记](https://segmentfault.com/a/1190000018914652)中，我们谈到了一种特殊情况：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/23/1556012827511.png)
 - 在b是char类型的时候，a和b的内存地址是紧邻的；如果b是int类型的话，就会出现如图所示的情况。我们可以这样记忆，不看b之后的字段，a和b之前也是按照它们的最小公倍数对齐的（如果b是int类型，a和b的最小公倍数是4，按4对齐；如果b是char类型，最小公倍数为1，按1对齐，就会出现a和b紧邻的情况）
 - 如果不想对齐，有如下解决方案：
    - 编译的时候不加优化参数
    - 代码层面：在struct后加关键字，例如redis中的sds简单动态字符串的实现：
    ```c
	    struct __attribute__ ((packed)) sdshdr16 {
			uint16_t len;
			uint16_t alloc;
			unsigned char flags;
			char buf[];
		}
	```
### 联合体
 - 所有字段共用一段内存，用于PHP中变量值的存储（因为变量只有一种类型），也可以用来判断机器的大小端问题。
## 宏定义