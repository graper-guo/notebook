# **【PHP源码学习】2019-03-18 复习前面的内容**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/7404d5327e095ee48529da5b5ea9a73d.flv.mp4

## malloc函数深入
 - 在[PHP内存管理1笔记](https://segmentfault.com/a/1190000018909215)中提到，malloc()函数会在分配的内存空间前面额外分配32位，用来存储分配的大小和几个标志位，如图：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/23/1556011070035.png)
 - 那么究竟是否是这样的呢？我们写一段测试代码验证一下：
```c
#include <stdlib.h>
int main() {
    void *ptr = malloc(8);
    return 1;
}
```
 - 利用gdb调试这段代码：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/23/1556011536132.png)
 - 首先打印ptr的地址，为0x602010，利用x命令往后看20个内存单元（1个内存单元 = 4个字节），故一共展示了80个字节，后面的x是以16进制打印内容。
 - 我们发现紧邻0x602010地址的上面32位均是0，没有任何内容，不符合我们的预期。
 - 上图只是一个最简单的思路，但绝大多数操作系统是按照如下的方式实现的：

>操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
   malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表（Free List）。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块(根据不同的算法而定（将最先找到的不小于申请的大小内存块分配给请求者，将最合适申请大小的空闲内存分配给请求者，或者是分配最大的空闲块内存块）。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。
   调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。

## 结构体与联合体
### 结构体
 - 在[PHP内存管理2笔记](https://segmentfault.com/a/1190000018914652)中，我们谈到了一种特殊情况：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/23/1556012827511.png)
 - 在b是char类型的时候，a和b的内存地址是紧邻的；如果b是int类型的话，就会出现如图所示的情况。我们可以这样记忆，不看b之后的字段，a和b之前也是按照它们的最小公倍数对齐的（如果b是int类型，a和b的最小公倍数是4，按4对齐；如果b是char类型，最小公倍数为1，按1对齐，就会出现a和b紧邻的情况）
 - 如果不想对齐，有如下解决方案：
    - 编译的时候不加优化参数
    - 代码层面：在struct后加关键字，例如redis中的sds简单动态字符串的实现：
    ```c
	    struct __attribute__ ((packed)) sdshdr16 {
			uint16_t len;
			uint16_t alloc;
			unsigned char flags;
			char buf[];
		}
	```
### 联合体
 - 所有字段共用一段内存，用于PHP中变量值的存储（因为变量只有一种类型），也可以用来判断机器的大小端问题。
## 宏定义
 - 宏就是替换。
 - 关于下面这段代码的复杂宏替换问题，在[PHP内存管理3笔记](https://segmentfault.com/a/1190000018927762)中已经有详细解释，此处不再赘述。
```c
#define _BIN_DATA_SIZE(num, size, elements, pages, x, y) size,
static const uint32_t bin_data_size[] = {
  ZEND_MM_BINS_INFO(_BIN_DATA_SIZE, x, y)
};
```
 - 关于C语言宏定义中的##等特殊符号的用法，参考：[【C基础】#define宏定义中的#，##，@#，\ 这些符号的神奇用法](https://blog.csdn.net/freeWayWalker/article/details/50220049)
## PHP基本变量
 - 在PHP7中，一个zval是16字节；在PHP5中，一个zval是48字节。
```c
struct _zval_struct {
    zend_value value;
    union u1;
    union u2;
};
```
 - 变量值的存放：PHP7中变量的值存在zend_value 这个联合体中。只有整型和浮点型是直接存在zend_value中，其余类型都只存放了一个指向专门存放该类型的结构体指针。这个联合体共占用8字节。
```c
typedef union _zend_value {
	zend_long         lval;	//整型
	double            dval;	//浮点
	zend_refcounted  *counted; //引用计数
	zend_string      *str; //字符串
	zend_array       *arr; //数组
	zend_object      *obj; //对象
	zend_resource    *res; //资源
	zend_reference   *ref; //引用
	zend_ast_ref     *ast; //抽象语法树
	zval             *zv;  //内部使用
	void             *ptr; //不确定类型，取出来之后强转
	zend_class_entry *ce;  //类
	zend_function    *func;//函数
	struct {
		uint32_t w1;
		uint32_t w2;
	} ww; //这个union一共8B，这个结构体每个字段都是4B，因为所有联合体字段共用一块内存，故相当于取了一半的union
} zend_value;
```
 - 变量类型的存放：在PHP7中，其变量的类型存放在zval中的u1联合体中：
```c
...
	union {
		struct {
			ZEND_ENDIAN_LOHI_4(
				zend_uchar    type,			/* 在这里用unsigned char存放PHP变量值的类型 */
				zend_uchar    type_flags,
				zend_uchar    const_flags,
				zend_uchar    reserved)	    /* call info for EX(This) */
		} v;
		uint32_t type_info;
	} u1;
...
```