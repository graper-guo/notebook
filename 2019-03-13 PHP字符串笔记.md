# **【PHP源码学习】2019-03-13 PHP字符串笔记**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

源视频地址：http://replay.xesv5.com/ll/2480/2dfb5176206c788d9e422cdae058be36.flv.mp4

## PHP7字符串
### 柔性数组的发展过程
 - 在C99的柔性数组标准未发布之前，我们如果存储一个字符串，可以使用如下代码：
```c
    struct string{
		...
        int len; //存长度
        char* val; //存真正的字符串值
    };
```
 - 那么我们发现，这样做有如下缺点：
    - 访问字符串值的时候，需要先访问结构体，在访问指针所指向的内存空间，需要2次内存访问，效率低下。
    - 释放字符串内存空间的时候，需要先释放char \*val指针所指向的内存空间，再释放结构体本身的内存空间，效率同样低下，而且这两个操作顺序不能颠倒。
  - 那么如何改进呢？很容易想到，我们将字符串值和结构体存储在一片连续的内存空间不就行了吗，这样的话，访问与释放均仅需1次内存访问，在C99柔性数组标准发布之前，改进代码的方式如下：
```c
int main() {

    struct string{
        int len;
    };

    typedef struct string str;

    char *s = "hello world";
    str *p = (str*)(malloc(sizeof(str) + strlen(s) + 1)); //分配足够存下一个字符串的结构体
    p->len = strlen(s);
    memcpy(p + 1, s, strlen(s)); //将字符串拷贝到紧邻结构体的内存处

}
```
 - 小插曲：这个代码的第一版，我还出现了一个指针加法的错误，见：[关于memcpy一个字符串到紧邻结构体内存空间处的疑问](https://segmentfault.com/q/1010000018945285)
 - 我们gdb调试一下这段代码：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/22/1555921657057.png)
 - 我们看到结构体本身和len字段的地址均是0x602010，len字段的长度为4B，加上4就应该是字符串he的起始地址，即0x602014。注意不是p+4，而是p+1。因为**p+4 = p+4*sizeof(指针p的类型)**
 - 由于这样编写代码过于繁琐，所以C99干脆制定一个标准，使用柔性数组代替上述写法。其实使用的计算方法和上面一段代码是一样的，只不过换了一种简化的写法而已。
### PHP字符串实现
```c
struct _zend_string {
	zend_refcounted_h gc;         /*引用计数，与垃圾回收相关，暂不展开*/
	zend_ulong        h;                /* 冗余的hash值，计算数组key的哈希值时避免重复计算*/
	size_t            len;                  /* 长度 */
	char              val[1];               /* 柔性数组 */
};
```
 - 第一个问题：为什么要存长度len？不存长度，直接和C语言一样通过字符串的'\0'来判断字符串结束不行吗？不行。这里有一个二进制安全的问题。
    - 二进制安全：写入的数据和读出来的数据完全相同，就是二进制安全的。
    - 假设你写入了一个字符串的内容为：hello\0world，按照C语言的读取字符串的方法就会判定\0是字符串结束的标志，读出来就是hello，这样读出来的数据就和写入的数据不一致，就是非二进制安全的。
    - 如果存了长度，就不会管你是否有\0，从头开始读字符串，一直读len长度为止即可。
 - 第二个问题：最后一个字段改成char val\[0]可以吗？可以。写成char val\[1]是出于可移植性的考虑。有些编译器不支持\[0]数组，可将其改成\[]或\[1]均可。