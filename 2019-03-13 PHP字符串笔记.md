# **【PHP源码学习】2019-03-13 PHP字符串笔记**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

源视频地址：http://replay.xesv5.com/ll/2480/2dfb5176206c788d9e422cdae058be36.flv.mp4

## 深入PHP7字符串
### 柔性数组的发展过程
 - 在C99的柔性数组标准未发布之前，我们如果存储一个字符串，可以使用如下代码：
```c
    struct string{
		...
        int len; //存长度
        char* val; //存真正的字符串值
    };
```
 - 那么我们发现，这样做有如下缺点：
    - 访问字符串值的时候，需要先访问结构体，在访问指针所指向的内存空间，需要2次内存访问，效率低下。
    - 释放字符串内存空间的时候，需要先释放char \*val指针所指向的内存空间，再释放结构体本身的内存空间，效率同样低下。
  - 那么如何改进呢？很容易想到，我们将字符串值和结构体存储在一片连续的内存空间不就行了吗，这样的话，访问与释放均仅需1次内存访问，在C99柔性数组标准发布之前，改进代码的方式如下：
```c
int main() {

    struct string{
        int len;
    };

    typedef struct string str;

    char *s = "hello world";
    str *p = (str*)(malloc(sizeof(str) + strlen(s) + 1));//分配足够存下一个字符串的结构体
    p->len = strlen(s);
    memcpy(p + 1, s, strlen(s));//将字符串拷贝到紧邻结构体的内存处

}
```
 - 小插曲：这个代码的第一版，还出现了一个指针加法的错误，见：[关于memcpy一个字符串到紧邻结构体内存空间处的疑问](https://segmentfault.com/q/1010000018945285)
 - 我们gdb调试一下这段代码：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/22/1555921657057.png)
 - 我们看到结构体本身和len字段的地址均是0x602010，len字段的长度为4B，加上4就应该是字符串he的起始地址，即0x602014。注意不是p+4，而是p+1。因为**p+4 = p+4*sizeof(指针p的类型)**
 - 由于这样编写代码过于繁琐，所以C99干脆制定一个标准，使用柔性数组代替上述写法。
```c
struct _zend_string {
	zend_refcounted_h gc;
	zend_ulong        h;                /* 冗余的hash值 */
	size_t            len;
	char              val[1];                /* 柔性数组 */
};
```
 - 柔性数组解决的问题：它是C99的新标准，方便动态地对字符串进行扩容（如helllo + world）这种字符串连接操作，sizeof()求出的结构体大小不包含柔性数组。
 - 思考：如果把柔性数组换成char \*是否可取？不可取。如果是char \*，如果我们来访问字符串的值，；而如果换成柔性数组，它放在结构体末尾，是紧邻len字段的一段连续内存空间，仅需1次内存访问，提升了性能。而且在释放内存的时候，可以将结构体和字符串值一起释放掉，避免二次释放。