# **【PHP源码学习】2019-03-20 词法分析**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/cf68765ff02ec88fa297d8a8b4f2b7fe.flv.mp4

## 基本概念
 - 在PHP7中，当一个请求到来时，先加载对应的PHP代码，后进行词法分析和语法分析并生成抽象语法树（AST），然后进行深度优先遍历并生成opcodes，在zend虚拟机中执行这些opcode并返回执行结果。在PHP中，使用的词法分析器是Re2c，语法分析器是Bison。
 - 词法分析：词法分析阶段是编译过程的第一个阶段。这个阶段的任务是从左到右一个字符一个字符地读入源程序，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号，即token)。词法分析程序实现这个任务。词法分析程序可以使用Re2c、lex等工具自动生成。
 - 语法分析：语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等。语法分析程序判断源程序在结构上是否正确。
 - 其实进行词法分析和语法分析并生成某种数据结构的过程，就是一个解码的过程。

> 之所以需要做这种从字符串到数据结构的转换，是因为编译器是无法直接操作“1+2”这样的字符串的。实际上，代码的本质根本就不是字符串，它本来就是一个具有复杂拓扑的数据结构，就像电路一样。“1+2”这个字符串只是对这种数据结构的一种“编码”，就像ZIP或者JPEG只是对它们压缩的数据的编码一样。
> 这种编码可以方便你把代码存到磁盘上，方便你用文本编辑器来修改它们（对人友好，方便人们编写代码，但是对编译器不友好），然而你必须知道，文本并不是代码本身。所以从磁盘读取了文本之后，你必须先“解码”，才能方便地操作代码的数据结构。比如，如果上面的Java代码生成的AST节点叫node，你就可以用node.operator来访问加号ADD，用node.left来访问1，node.right来访问2。这是很方便的。对于程序语言，这种解码的动作就叫做parsing，用于解码的那段代码就叫做parser。

 - 关于语法分析与词法分析的具体概念解释，这篇文章写得较好：[对 Parser 的误解](http://www.yinwang.org/blog-cn/2015/09/19/parser)
 - 我们先利用PHP内置函数token_get_all()来取出一段PHP代码的token：
```php
<?php
$lan = '<?php $a = 1; echo $a';
$tokens = token_get_all($lan);
foreach ($tokens as $token) {
    if (is_array($token)) {
        echo "Line {$token[2]}: ", token_name($token[0]), " ('{$token[1]}')", PHP_EOL;
    }
}
```
 - 打印结果为：
```
Line 1: T_OPEN_TAG ('<?php ')
Line 1: T_VARIABLE ('$a')
Line 1: T_WHITESPACE (' ')
Line 1: T_WHITESPACE (' ')
Line 1: T_LNUMBER ('1')
Line 1: T_WHITESPACE (' ')
Line 1: T_ECHO ('echo')
Line 1: T_WHITESPACE (' ')
Line 1: T_VARIABLE ('$a')

```
 - 观察以上结果，可以看到取出来的token。
## 如何取出token
 - 那么让我们你自己去设计一个算法，从一个字符串中识别并取出token，应该怎么做？
    - 使用两个指针，一个标记开始位置，一个往后挪，然后回溯。（较麻烦）
    - 使用正则表达式进行匹配
  - 当用较简单的字符串匹配正则表达式的时候，可以用人眼很容易地看出来。但是如果用很复杂的字符串（成千上万行代码）去匹配一个正则，是相当麻烦并且非常慢的，编译原理中提出了这样一个概念用以解决这个问题：**有穷状态机**。
  - 有穷状态机：必须有一个起始状态，用一个箭头加圆圈表示；也得有一个结束，用两个圆圈表示。 如果满足某个条件，就会从一个状态跃迁到另一个状态，也用箭头来表示。
例：观察下面这个正则表达式：
```
(a|b)*abb
```
 - 根据这个正则表达式，我们可以画出它的有穷状态机：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/26/1556243808028.png)
    - 对于a，只能到状态0或者1，不能到达结束的3，所以不匹配
    - 对于abb，第一个a可以使状态0跃迁到1，第二个b可以从1跃迁到2，最后一个b结束，所以匹配
    - 对于aabb，第一个a可以选择从0跃迁到0，第二个从0跃迁到1，后面两个b同上，匹配
    - 对于cabb，第一个c就无法满足，不匹配
 - 这里有个问题，输入第一个a的时候，可以从0跃迁到自己，也可以从0跃迁到1，所以这种状态机就叫**不确定有穷状态机**（NFA）
 - NFA是有缺陷的，比如aabb，有可能一直从0跃迁到0，共重复了4次这样的操作，也没有到达最终的结束状态3。这就会导致本应该符合匹配要求的字符串，在不确定有穷状态机中，错误地被判定为不符合匹配要求。解决此问题的办法就是将不确定有穷状态机转化为确定有穷状态机（DFA）。
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/26/1556244802016.png)
 - 这样一来，一个确定的输入就对应着一个确定的输出（假设如给一个a，一定跃迁到1；给一个b，一定跃迁回0），不存在歧义问题。
 - 但是，将一个NFA转化成DFA是相当复杂的，所以有工具已经为我们做好了这个事情：Re2c。你只需要输入一个正则表达式，就能够为你生成一个确定有穷状态机（DFA），在Re2c工具中以C/C++代码体现，详情见：[re2c中文手册](http://w3w.reeze.cn/book/?p=G-re2c-mannual)