# **【PHP源码学习】2019-03-20 词法分析**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2627/cd54a55ab431c848c29d73b22b331fdd.flv.mp4

## 基本概念
 - token：
 - 我们先利用PHP内置函数token_get_all()来取出一段PHP代码的token：
```php
<?php
$lan = '<?php $a = 1; echo $a';
$tokens = token_get_all($lan);
foreach ($tokens as $token) {
    if (is_array($token)) {
        echo "Line {$token[2]}: ", token_name($token[0]), " ('{$token[1]}')", PHP_EOL;
    }
}
```
 - 打印结果为：
```
Line 1: T_OPEN_TAG ('<?php ')
Line 1: T_VARIABLE ('$a')
Line 1: T_WHITESPACE (' ')
Line 1: T_WHITESPACE (' ')
Line 1: T_LNUMBER ('1')
Line 1: T_WHITESPACE (' ')
Line 1: T_ECHO ('echo')
Line 1: T_WHITESPACE (' ')
Line 1: T_VARIABLE ('$a')

```
 - 观察以上结果，可以看到取出来的token。
 - 那么让我们你自己去设计一个算法，从一个字符串中取出token，应该怎么做？
    - 使用两个指针，一个标记开始位置，一个往后挪，然后回溯。（较麻烦）
    - 使用正则表达式
  - 当用较简单的字符串匹配正则表达式的时候，可以用人眼很容易地看出来。但是如果用很复杂的字符串（成千上万行代码）去匹配一个正则，是相当麻烦的，编译原理中提出了这样一个概念用以解决这个问题：**有穷状态机**。
  - 有穷状态机：必须有一个起始状态，用一个箭头加圆圈表示；也得有一个结束，用两个圆圈表示。 如果满足某个条件，就会从一个状态跃迁到另一个状态，也用箭头来表示。
例：观察下面这个正则表达式：
```
(a|b)*abb
```
 - 根据这个正则表达式，我们可以画出它的有穷状态机：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/26/1556243808028.png)
    - 对于a，只能到状态0或者1，不能到达结束的3，所以不匹配
    - 对于abb，第一个a可以使状态0跃迁到1，第二个b可以从1跃迁到2，最后一个b结束，所以匹配
    - 对于aabb，第一个a可以选择从0跃迁到0，第二个从0跃迁到1，后面两个b同上，匹配
    - 对于cabb，第一个c就无法满足，不匹配
 - 这里有个问题，输入第一个a的时候，可以从0跃迁到自己，也可以从0跃迁到1，所以这种状态机就叫**不确定有穷状态机**（NFA）
 - NFA是有缺陷的，比如aabb，有可能一直从0跃迁到0，共重复了4次这样的操作，也没有到达最终的结束状态3。这就会导致本应该符合匹配要求的字符串，在不确定有穷状态机中，错误地被判定为不符合匹配要求。解决此问题的办法就是将不确定有穷状态机转化为确定有穷状态机（DFA）。
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/26/1556244802016.png)
 - 这样一来，一个确定的输入就对应着一个确定的输出（假设如给一个a，一定跃迁到1；给一个b，一定跃迁回0），不存在歧义问题。
 - 但是，将一个NFA转化成DFA是相当复杂的，所以有人已经为我们做好了这个事情：Re2c。你只需要输入一个正则表达式，就能够为你生成一个确定有穷状态机（DFA）