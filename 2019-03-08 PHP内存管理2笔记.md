# **2019-03-08 PHP内存管理2笔记**
视频地址：http://replay.xesv5.com/ll/2480/92c4f2bfb31f013b2f3866d07bcac038.flv.mp4
## 复习
 - AG：alloc globals 全局变量
```c
typedef struct _zend_alloc_globals {
	zend_mm_heap *mm_heap;
} zend_alloc_globals;
...
# define AG(v) (alloc_globals.v)
static zend_alloc_globals alloc_globals;
```
这个带有参数的宏取得zend_alloc_globals里的zend_mm_heap结构体字段，如AG(mm_heap) = alloc_globals.mm_heap，宏就是替换。
## 结构体与结构体内存对齐
### 结构体
 - 先看一段结构体代码struct.c：
```c
#include <stdio.h>
int main() {
    struct a{
        char a;
        int b;
        long c;
        void *d;
        int e;
        char *f;
    }s;
    s.a = 'c';
    s.b = 1;
    s.c = 22l;
    s.d = NULL;
    s.e = 1;
    s.f = &s.a;
    printf("sizeof struct a is %d", (int)sizeof(s));
}
```
 - 编译：gcc -g struct.c -o struct
 - 运行：./struct，sizeof(a)的打印结果为：40
 - 对这个结构体进行gdb调试：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555510539779.png)
 - 在这里我们可以看到第一行是所有结构体变量的初始值，注意指针变量是一个随机的地址，在给s.d赋值的过程中，地址变成了0x0，它是一个特殊的地址值，代表NULL。
 - 除此之外，我们注意到结构体s的地址和a变量的地址是相同的。
 - 用表达式表示以上结论：&s = &s.a = f或者s = s.a  = \*f
### 结构体内存对齐
 - 核心结论：编译器做的优化，以空间换时间。**按照结构体占用空间最大的字段做对齐（最大是8B就按8B对齐；最大4B就按4B对齐），且和结构体字段的排列顺序是相关的**。如图：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555503078430.png)
 - 我们利用gdb验证一下以上的结论，还是利用上述同样的代码：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555511244920.png)
 - 我们看到变量a的起始地址是150，而b的地址是154，显然做了对齐。如果不对齐，b的地址应该为151，说明a和b中间空了3B的大小。c的地址是158，就是下一个8B的起始地址，而d的地址是160（注意这里是16进制，158+8 = 160的时候才会进位），证明了c占用了8B，下面d变量也同理占用了8B。注意e变量，它是一个int，如果不对齐应该只占用4B。而它占用了170（f的起始地址）- 168（e的起始地址） = 8B，所以一定是做了内存对齐的。
 - 注意：如果b是一个char类型，那么是直接紧跟在上一个char后面，如图：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555512054170.png)
 - 注意这里的地址均为逻辑地址，每次编译后的逻辑地址是相同的，而物理地址是不同的。
 - 注意：如果调换顺序，把b和c调换位置，就会变成8B(a)+8B(c)+8B(b)+8B(d)+8B(e)+8B(f) = 48B
## 联合体
 - 核心结论：**所有联合体字段共用一块内存空间**。整个联合体占用的空是所有字段单独占用空间大小中取占用空间大小最大的字段。
 - 同样先看一段代码：
```c
#include <stdio.h>
int main() {
    union a{
        char a;
        int b;
        long c;
        void *d;
        int e;
        char *f;
    }s;
    s.a = 'c';
    s.b = 1;
    s.c = 22l;
    s.d = NULL;
    s.e = 1;
    s.f = &s.a;
    printf("sizeof struct a is %d", (int)sizeof(s));
}
```
 - 这段代码与上段结构体的代码只将struct修改为union，其他均不变
 - 编译运行，输出sizeof(a)的结果为：8
 - 我们利用gdb调试一下这段代码：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555512839411.png)
 - 我们可以看到，后面的变量一赋值，就会覆盖前面的变量值
 - 再看一下每个变量的地址，我们可以清楚地看到，所有变量的起始地址都是一样的。
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555513004227.png)
