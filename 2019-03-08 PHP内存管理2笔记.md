# **2019-03-08 PHP内存管理2笔记**
视频地址：http://replay.xesv5.com/ll/2480/92c4f2bfb31f013b2f3866d07bcac038.flv.mp4
## 复习
 - AG：alloc globals 全局变量
```c
typedef struct _zend_alloc_globals {
	zend_mm_heap *mm_heap;
} zend_alloc_globals;
...
# define AG(v) (alloc_globals.v)
static zend_alloc_globals alloc_globals;
```
这个带有参数的宏取得zend_alloc_globals里的zend_mm_heap结构体字段，如AG(mm_heap) = alloc_globals.mm_heap，宏就是替换。
## 结构体与结构体内存对齐
### 结构体
 - 先看一段结构体代码struct.c：
```c
#include <stdio.h>
int main() {
    struct a{
        char a;
        int b;
        long c;
        void *d;
        int e;
        char *f;
    }s;
    s.a = 'c';
    s.b = 1;
    s.c = 22l;
    s.d = NULL;
    s.e = 1;
    s.f = &s.a;
    printf("sizeof struct a is %d", (int)sizeof(s));
}
```
 - 编译：gcc -g struct.c -o struct
 - 运行：./struct，sizeof的打印结果为40
 - 对这个结构体进行gdb调试：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555510539779.png)
 - 在这里我们可以看到第一行是所有结构体变量的初始值，注意指针变量是一个随机的地址，在给s.d赋值的过程中，地址变成了0x0，它是一个特殊的地址值，代表NULL。
 - 除此之外，我们注意到结构体s的地址和a变量的地址是相同的。
 - 用表达式表示以上结论：&s = &s.a = f或者s = s.a  = \*f
### 结构体内存对齐
 - 核心：编译器做的优化，以空间换时间。**按照结构体占用空间最大的字段做对齐（最大是8B就按8B对齐；最大4B就按4B对齐），且和结构体字段的排列顺序是相关的**。如图：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555503078430.png)
 - 我们利用gdb验证一下以上的结论：
![enter description here](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/17/1555511244920.png)
 - 我们看到变量a的起始地址是150，而b的地址是154，显然做了对齐。如果不对齐，b的地址应该为151，说明a和b中间空了3B的大小。c的地址是158，就是下一个8B的起始地址，而d的地址是160（注意这里是16进制，158+8 = 160的时候才会进位），证明了c占用了8B，下面d变量也同理占用了8B。注意e变量，它是一个int，如果不对齐应该只占用4B。而它占用了170（f的起始地址）- 168（e的起始地址） = 8B，所以一定是做了内存对齐的。
 - 注意这里的地址均为逻辑地址，每次编译后的逻辑地址是相同的，而物理地址是不同的。
 - 注意：如果调换顺序，把b和c调换位置，就会变成8B(a)+8B(c)+8B(b)+8B(d)+8B(e)+8B(f) = 48B
## 联合体
 - 核心：所有联合体字段共用一块内存空间。整个联合体占用的空间是所有字段占用空间取最大值。