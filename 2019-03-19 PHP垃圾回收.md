# **【PHP源码学习】2019-03-19 垃圾回收**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/7404d5327e095ee48529da5b5ea9a73d.flv.mp4

## PHP中的引用
 - 语法：
```php
$b = &$a;
```
 - 引用将a和b两个变量强制指向一块内存空间，这样就可以用a和b两个变量名访问同一个变量内容，同时赋值等号两边的变量都变成了IS_REFERENCE类型。
 - 在PHP7中，在使用完引用运算符后，会在内存中增加一个zend_reference结构体。我们看一下它的结构：
```c
struct _zend_reference {
	zend_refcounted_h gc; //gc相关，存有refcount
	zval              val;   //利用zval的zend_value字段存储指向zend_array或zend_string等复杂类型的原始数据结构的指针，来找到这个变量的值
};
```
 - 这个结构体一共只有2个字段，gc字段中存储了引用计数，而zval指向某一个具体类型的数据结构(如zend_string或是zend_array等)，它的类型是对应的IS_STRING或IS_ARRAY类型，这样增加了一个中间层，让原始的zend_string或zend_array在内存中只有1份，方便管理与维护。
 - 同时我们可以知道，由于简单类型（整型、浮点型）的值是直接存在zval中的。与zend_string这种复杂数据结构不同，简单类型除了基本的zval，不需要在内存额外开辟空间，所以不需要使用zend_reference结构体。
 - 我们利用一段PHP代码来观察引用变量的存储情况：
```php
<?php
$a = ['time' => time()];
echo $a;
$a[] = &$a; //循环引用
echo $a;
unset($a);
echo $a;
```
 - 由于开启opcache的PHP7会在数组初始化的元素全部为常量元素的时候，将其优化成不可变数组(immutable array)，这里的引用计数值refcount = 2只是一个伪引用计数，所以我们使用$a = ['time' => time()]，让其初始化后的refcount为正常的1。]见下图：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/25/1556155029205.png)
 - 利用gdb调试这段代码：
 - 执行完$a初始化并打印$a，refcount为1，type为7(IS_ARRAY)而此时的ref字段中的值是非法地址，说明此时还没有生成中间的zend_reference结构体:
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/25/1556155622890.png)
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/25/1556156877674.png)

 - 继续执行下一行$a[] = &$a; 观察下图中绿色方框的含义：此时的$a的zval中的ref指向zend_reference结构体，zend_reference结构体中的zval字段中的arr指针指向了原始的zend_array，zend_array中的bucket数组元素也是一个IS_REFERENCE类型，它又指回到同一个zend_reference结构体：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/25/1556158581866.png)
 - 根据gdb调试情况画出内存结构图：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/25/1556159268480.png)
 - 由于zend_reference有两个东西指向它（一个是$a，一个是$a数组中的一个元素），所以refcount = 2。原始的zend_array中也有一个refcount字段，由于只有一个zend_reference指向这个zend_array，所以refcount = 1。
 - 接下来继续执行unset($a)：
![](http://pq370w15r.bkt.clouddn.com/notebook/2019/4/25/1556159550645.png)
 - 我们可以看到，$a的type类型变成了0(IS_UNDEF)，同时其指向的zend_reference结构体的refcount变为了1(因为$a数组中的元素仍然在指向它)。
 - 那么问题出现了，$a是unset掉了，但是zend_reference的refcount仍然是1而并非是预期的0。这个zend_reference与原始zend_array数组的连接也并未断掉。这样一来，这两个zend_reference与zend_array结构在unset($a)之后，仍然存在于内存之中，如果对此不作任何处理，就会造成内存泄漏。
 - 那么如何解决循环引用带来的内存泄漏问题呢？**垃圾回收**就要派上用场了。
## PHP7中的垃圾回收