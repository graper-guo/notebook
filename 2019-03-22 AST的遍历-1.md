# **【PHP源码学习】2019-03-22 AST的遍历-1**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/8e1b791bb452497dab0e2c39e4791038.flv.mp4

## 引入
 - 先看上一节笔记中展示的AST示例：
```php
<?php
$a = 1;
$b = $a + 2;
```
 - 在PHP中，构造出来的抽象语法树如图所示：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/5/14/1557813143220.png)
 - 那么，这个AST后面能够用来做什么呢？因为我们最终需要执行这段PHP代码，所以需要将其转化为可执行的指令来执行。
 - 指令的几个要素：操作数（OP1、OP2，两个就够了，因为多元运算可以转化成二元运算）、做哪种操作（handler）、运算结果（result）。这些指令要素是我们自己定义的，而寄存器是无法理解这些自定义指令的，这就需要**虚拟机（zendvm）** 去进行指令转换工作并且真正的执行这些指令。
 - 回到AST，那么我们如何对其进行遍历，才能得到一条条的指令呢？
 - 回想昨天调试的zend_compile断点处，它是编译的入口，并返回生成结果op_array
```c
static zend_op_array *zend_compile(int type)
{
	zend_op_array *op_array = NULL;
	zend_bool original_in_compilation = CG(in_compilation);

	CG(in_compilation) = 1;//CG宏可以取得zend_globals结构体中的字段
	CG(ast) = NULL;//一开始的AST为NULL
	CG(ast_arena) = zend_arena_create(1024 * 32);//给AST分配空间

	if (!zendparse()) { //进行词法和语法分析
		int last_lineno = CG(zend_lineno);
		zend_file_context original_file_context;
		zend_oparray_context original_oparray_context;
		zend_op_array *original_active_op_array = CG(active_op_array);

		op_array = emalloc(sizeof(zend_op_array));
		init_op_array(op_array, type, INITIAL_OP_ARRAY_SIZE);
		CG(active_op_array) = op_array;

		if (zend_ast_process) {
			zend_ast_process(CG(ast));
		}

		zend_file_context_begin(&original_file_context);
		zend_oparray_context_begin(&original_oparray_context);
		zend_compile_top_stmt(CG(ast)); //进行AST从上到下的分析，传入的参数就是ast
		CG(zend_lineno) = last_lineno;
		zend_emit_final_return(type == ZEND_USER_FUNCTION);
		op_array->line_start = 1;
		op_array->line_end = last_lineno;
		pass_two(op_array);
		zend_oparray_context_end(&original_oparray_context);
		zend_file_context_end(&original_file_context);

		CG(active_op_array) = original_active_op_array;
	}

	zend_ast_destroy(CG(ast));
	zend_arena_destroy(CG(ast_arena));

	CG(in_compilation) = original_in_compilation;

	return op_array;
}
```
 - 重点关注zend_op_array这个类型，他是一个数组，存储所有的指令。来看看它的结构：
```c
struct _zend_op_array {
	...
	uint32_t last; //数组的长度
	zend_op *opcodes;//数组具体指令的值
	...
};
```
 - 继续看zend_op类型的结构：
```c
struct _zend_op {
	const void *handler; //操作
	znode_op op1; //操作数1
	znode_op op2; //操作数2
	znode_op result; //操作结果
	uint32_t extended_value;
	uint32_t lineno;
	zend_uchar opcode;
	zend_uchar op1_type;
	zend_uchar op2_type;
	zend_uchar result_type;
};
```
 - 可以看到，和我们刚才讲过的一样，指令的几大要素都在此有所体现 ，和汇编指令特别相似。
 - 那么下面讲一下如何从AST，生成多条zend_op指令
 - 关注zend_compile中的zend_compile_top_stmt(CG(ast))这个函数调用，它会对AST进行遍历与分析：
```c
void zend_compile_top_stmt(zend_ast *ast)
{
	if (!ast) {
		return;
	}

	if (ast->kind == ZEND_AST_STMT_LIST) { //如果是这个AST是LIST类型
		zend_ast_list *list = zend_ast_get_list(ast);//将其转换成ZEND_AST_LIST类型即可（上一篇笔记是在gdb下直接强转的）
		uint32_t i;
		for (i = 0; i < list->children; ++i) {
			zend_compile_top_stmt(list->child[i]); //递归调用，进行深度遍历
		}
		return;
	}

	zend_compile_stmt(ast); //当递归调用自己的时候，如果往下走的时候并非LIST型结点，会调用这个函数

	if (ast->kind != ZEND_AST_NAMESPACE && ast->kind != ZEND_AST_HALT_COMPILER) {
		zend_verify_namespace();
	}
	if (ast->kind == ZEND_AST_FUNC_DECL || ast->kind == ZEND_AST_CLASS) {
		CG(zend_lineno) = ((zend_ast_decl *) ast)->end_lineno;
		zend_do_early_binding();
	}
}
```
 - 内联函数（inline）：普通的函数调用是需要压栈的，而内联函数直接将函数体代码嵌入到调用位置，提高代码执行效率
 - 具体代码执行过程（按照最开始的AST图来讲）：
    - 根节点进来，判断是ZEND_AST_LIST类型（132），故将其强转成ZEND_AST_LIST类型
    - 递归调用函数本身，参数传入其第一个子结点（517，赋值运算符）
    - 赋值运算符不是LIST类型，往下走到zend_compile_stmt(ast)中
 - 接下来看下zend_compile_stmt(ast)具体实现：
```c
void zend_compile_stmt(zend_ast *ast) 
{
	if (!ast) {
		return;
	}

	CG(zend_lineno) = ast->lineno;

	if ((CG(compiler_options) & ZEND_COMPILE_EXTENDED_INFO) && !zend_is_unticked_stmt(ast)) {
		zend_do_extended_info();
	}

	switch (ast->kind) {
		case ZEND_AST_STMT_LIST:
			zend_compile_stmt_list(ast);
			break;
		case ZEND_AST_GLOBAL:
			zend_compile_global_var(ast);
			break;
		case ZEND_AST_STATIC:
			zend_compile_static_var(ast);
			break;
		......
		default: //最终会走到这里，因为所有的case中，没有ZEND_AST_ASSIGN类型与之匹配
		{
			znode result; //声明了一个znode类型变量，存储中间结果
			zend_compile_expr(&result, ast); //调用这个函数，下面会展开
			zend_do_free(&result);
		}
	}

	if (FC(declarables).ticks && !zend_is_unticked_stmt(ast)) {
		zend_emit_tick();
	}
}
```
 - 代码最终会走到default分支
 - 首先声明一个znode类型的变量result，看一下znode类型的结构：
```c
typedef struct _znode { /* used only during compilation */
	zend_uchar op_type;
	zend_uchar flag;
	union {
		znode_op op;
		zval constant; /* replaced by literal/zv */
	} u;
} znode;
```
 - 重点关注这个联合体中的constant字段，它是一个zval，后面可以用来存储中间值
 - 接下来会调用zend_compile_expr函数，继续跟进zend_compile_expr(&result, ast)，注意这里的ast是517位根节点的子树而非最开始的ast。看一下这个函数的具体实现：
```c
void zend_compile_expr(znode *result, zend_ast *ast) 
{
	/* CG(zend_lineno) = ast->lineno; */
	CG(zend_lineno) = zend_ast_get_lineno(ast);

	switch (ast->kind) {
		case ZEND_AST_ZVAL:
			ZVAL_COPY(&result->u.constant, zend_ast_get_zval(ast));
			result->op_type = IS_CONST;
			return;
		case ZEND_AST_ZNODE:
			*result = *zend_ast_get_znode(ast);
			return;
		case ZEND_AST_VAR:
		case ZEND_AST_DIM:
		case ZEND_AST_PROP:
		case ZEND_AST_STATIC_PROP:
		case ZEND_AST_CALL:
		case ZEND_AST_METHOD_CALL:
		case ZEND_AST_STATIC_CALL:
			zend_compile_var(result, ast, BP_VAR_R);
			return;
		case ZEND_AST_ASSIGN:
			zend_compile_assign(result, ast); //代码走到这里，调用这个函数，下面继续跟进
			return;
		case ZEND_AST_ASSIGN_REF:
			zend_compile_assign_ref(result, ast);
			return;
		case ZEND_AST_NEW:
			zend_compile_new(result, ast);
			return;
		case ZEND_AST_CLONE:
			zend_compile_clone(result, ast);
			return;
		case ZEND_AST_ASSIGN_OP:
			zend_compile_compound_assign(result, ast);
			return;
		case ZEND_AST_BINARY_OP:
			zend_compile_binary_op(result, ast);
			return;
		......
	}
}
``` 
 - 最终上面代码会走到ZEND_AST_ASSIGN的case中，并调用zend_compile_assign(result, ast)函数，继续跟进这个函数：
```c
void zend_compile_assign(znode *result, zend_ast *ast)
{
	zend_ast *var_ast = ast->child[0]; //517的第一个孩子
	zend_ast *expr_ast = ast->child[1]; //517的第二个孩子

	znode var_node, expr_node;
	zend_op *opline;
	uint32_t offset;

	if (is_this_fetch(var_ast)) {
		zend_error_noreturn(E_COMPILE_ERROR, "Cannot re-assign $this");
	}

	zend_ensure_writable_variable(var_ast);

	switch (var_ast->kind) {
		case ZEND_AST_VAR:
		case ZEND_AST_STATIC_PROP:
			offset = zend_delayed_compile_begin();
			zend_delayed_compile_var(&var_node, var_ast, BP_VAR_W);
			zend_compile_expr(&expr_node, expr_ast);//重点注意：代码走到这里，根据传入的参数可以看出，它又去解析517的第二个孩子
			zend_delayed_compile_end(offset);
			zend_emit_op(result, ZEND_ASSIGN, &var_node, &expr_node);
			return;
		......
		EMPTY_SWITCH_DEFAULT_CASE();
	}
}
```
 - 我们现在进行的是$a = 1的赋值操作，我们根据中间的等号，把它分成两部分：左边的变量部分、右边的表达式部分（这里因为表达式很简单就是1）
 - 现在我们传入的ast是517，它的左子树是256（ZEND_AST_VAR），右子树是64（ZEND_AST_ZVAL）
 - 首先取出它的两个孩子，然后对第一个孩子进行switch，走到ZEND_AST_STATIC_PROP这个case中，执行了5个函数。前两个函数是做一些标记，先忽略，重点关注第三个zend_compile_expr函数（之前我们调用过它），传入的参数是517的第二个孩子（即64），它目前正在解析$a = 1的右半部分（即上文提到的表达式部分）
 - 会走到zend_compile_expr函数的ZEND_AST_ZVAL这个case，看下这个case：
```c
		case ZEND_AST_ZVAL:
			ZVAL_COPY(&result->u.constant, zend_ast_get_zval(ast));
			result->op_type = IS_CONST;
			return;
```
 - 它调用了一个ZVAL_COPY宏，将这个ZEND_AST_ZVAL类型的结点的zval字段中存储的值（即1对应的zval），拷贝到之前声明的znode类型变量result的u.constant字段中
 - 看一下这个zend_ast_get_zval(ast)的具体实现：
```c
static zend_always_inline zval *zend_ast_get_zval(zend_ast *ast) {
	ZEND_ASSERT(ast->kind == ZEND_AST_ZVAL);
	return &((zend_ast_zval *) ast)->val;
}
```
 - 先忽略断言，它直接利用强转并取出val字段的值，就是1对应的zval，并返回了它的地址
 - 接下来再看一下ZVAL_COPY这个宏，它的功能是把一个zval拷贝到另外一个zval中：
```c
#define ZVAL_COPY(z, v)																				\
	do {																										   \
		zval *_z1 = (z);																					   \
		const zval *_z2 = (v);																			   \
		zend_refcounted *_gc = Z_COUNTED_P(_z2);									 \
		uint32_t _t = Z_TYPE_INFO_P(_z2);													   \
		ZVAL_COPY_VALUE_EX(_z1, _z2, _gc, _t);											\
		if ((_t & (IS_TYPE_REFCOUNTED << Z_TYPE_FLAGS_SHIFT)) != 0) { \
			GC_REFCOUNT(_gc)++;																	  \
		}																											  \
	} while (0)
```
 - 