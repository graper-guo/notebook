# **【PHP源码学习】2019-03-22 AST的遍历-1**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/8e1b791bb452497dab0e2c39e4791038.flv.mp4

## 引入
 - 先看上一节笔记中展示的AST示例：
```php
<?php
$a = 1;
$b = $a + 2;
```
 - 在PHP中，构造出来的抽象语法树如图所示：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/5/14/1557813143220.png)
 - 那么，这个AST后面能够用来做什么呢？因为我们最终需要执行这段PHP代码，所以需要将其转化为可执行的指令来执行。
 - 指令的几个要素：操作数（OP1、OP2，两个就够了，因为多元运算可以转化成二元运算）、做哪种操作（handler）、运算结果（result）。这些指令要素是我们自己定义的，而寄存器是无法理解这些自定义指令的，这就需要**虚拟机（zendvm）** 去进行指令转换工作并且真正的执行这些指令。
 - 回到AST，那么我们如何对其进行遍历，才能得到一条条的指令呢？
## AST的遍历与编译
### 基本结构
 - 回想昨天调试的zend_compile断点处，它是编译的入口，并返回生成结果op_array
```c
static zend_op_array *zend_compile(int type)
{
	zend_op_array *op_array = NULL;
	zend_bool original_in_compilation = CG(in_compilation);

	CG(in_compilation) = 1;//CG宏可以取得zend_globals结构体中的字段
	CG(ast) = NULL;//一开始的AST为NULL
	CG(ast_arena) = zend_arena_create(1024 * 32);//给AST分配空间

	if (!zendparse()) { //进行词法和语法分析
	
		.......
		//初始化op_array，用来存放指令
		op_array = emalloc(sizeof(zend_op_array));
		init_op_array(op_array, type, INITIAL_OP_ARRAY_SIZE);
		CG(active_op_array) = op_array;

		......
		//对AST进行遍历，传入的参数就是ast
		zend_compile_top_stmt(CG(ast)); 
		
		......
		 //设置handler
		pass_two(op_array);
	
	}
	return op_array;
}
```
 - 重点关注zend_op_array这个类型，它是一个数组，用来存储所有的指令。来看看它的结构：
```c
struct _zend_op_array {
	...
	uint32_t last; //数组的长度
	zend_op *opcodes;//数组具体指令的值
	...
};
```
 - 继续看zend_op类型的结构：
```c
struct _zend_op {
	const void *handler; //操作
	znode_op op1; //操作数1
	znode_op op2; //操作数2
	znode_op result; //操作结果
	uint32_t extended_value;
	uint32_t lineno;
	zend_uchar opcode;
	zend_uchar op1_type;
	zend_uchar op2_type;
	zend_uchar result_type;
};
```
 - 可以看到，和我们刚才讲过的一样，指令的几大要素都在此有所体现 ，和汇编指令特别相似。
 - 那么下面讲一下如何遍历这课抽象语法树
### 遍历抽象语法树
 - 关注zend_compile中的zend_compile_top_stmt(CG(ast))这个函数调用，它会对AST进行遍历与分析：
```c
void zend_compile_top_stmt(zend_ast *ast)
{
	if (!ast) {
		return;
	}

	if (ast->kind == ZEND_AST_STMT_LIST) { //如果是这个AST是LIST类型
		zend_ast_list *list = zend_ast_get_list(ast);//将其转换成ZEND_AST_LIST类型即可（上一篇笔记是在gdb下直接强转的）
		uint32_t i;
		for (i = 0; i < list->children; ++i) {
			zend_compile_top_stmt(list->child[i]); //递归调用，进行深度遍历
		}
		return;
	}

	zend_compile_stmt(ast); //当递归调用自己的时候，如果往下走的时候并非LIST型结点，会调用这个函数

	if (ast->kind != ZEND_AST_NAMESPACE && ast->kind != ZEND_AST_HALT_COMPILER) {
		zend_verify_namespace();
	}
	if (ast->kind == ZEND_AST_FUNC_DECL || ast->kind == ZEND_AST_CLASS) {
		CG(zend_lineno) = ((zend_ast_decl *) ast)->end_lineno;
		zend_do_early_binding();
	}
}
```
 - 内联函数（inline）：普通的函数调用是需要压栈的，而内联函数直接将函数体代码嵌入到调用位置，提高代码执行效率
 - 具体代码执行过程（按照最开始的AST图来讲）：
    - 根节点进来，判断是ZEND_AST_LIST类型（132），故将其强转成ZEND_AST_LIST类型
    - 递归调用函数本身，参数传入其第一个子结点（517，赋值运算符）
    - 赋值运算符不是LIST类型，往下走到zend_compile_stmt(ast)中
 - 接下来看下zend_compile_stmt(ast)具体实现：
```c
void zend_compile_stmt(zend_ast *ast) 
{
	if (!ast) {
		return;
	}

	CG(zend_lineno) = ast->lineno;

	if ((CG(compiler_options) & ZEND_COMPILE_EXTENDED_INFO) && !zend_is_unticked_stmt(ast)) {
		zend_do_extended_info();
	}

	switch (ast->kind) {
		case ZEND_AST_STMT_LIST:
			zend_compile_stmt_list(ast);
			break;
		case ZEND_AST_GLOBAL:
			zend_compile_global_var(ast);
			break;
		case ZEND_AST_STATIC:
			zend_compile_static_var(ast);
			break;
		......
		default: //最终会走到这里，因为所有的case中，没有ZEND_AST_ASSIGN类型与之匹配
		{
			znode result; //声明了一个znode类型变量，存储中间结果
			zend_compile_expr(&result, ast); //调用这个函数，下面会展开
			zend_do_free(&result);
		}
	}

	if (FC(declarables).ticks && !zend_is_unticked_stmt(ast)) {
		zend_emit_tick();
	}
}
```
 - 代码最终会走到default分支
 - 首先声明一个znode类型的变量result，看一下znode类型的结构：
```c
typedef struct _znode { /* used only during compilation */
	zend_uchar op_type;
	zend_uchar flag;
	union {
		znode_op op;
		zval constant; /* replaced by literal/zv */
	} u;
} znode;
```
 - 重点关注这个联合体中的constant字段，它是一个zval，后面可以用来存储中间值
 - 接下来会调用zend_compile_expr函数，继续跟进zend_compile_expr(&result, ast)，注意这里的ast是517位根节点的子树而非最开始的ast。看一下这个函数的具体实现：
```c
void zend_compile_expr(znode *result, zend_ast *ast) 
{
	/* CG(zend_lineno) = ast->lineno; */
	CG(zend_lineno) = zend_ast_get_lineno(ast);

	switch (ast->kind) {
		case ZEND_AST_ZVAL:
			ZVAL_COPY(&result->u.constant, zend_ast_get_zval(ast));
			result->op_type = IS_CONST;
			return;
		case ZEND_AST_ZNODE:
			*result = *zend_ast_get_znode(ast);
			return;
		case ZEND_AST_VAR:
		case ZEND_AST_DIM:
		case ZEND_AST_PROP:
		case ZEND_AST_STATIC_PROP:
		case ZEND_AST_CALL:
		case ZEND_AST_METHOD_CALL:
		case ZEND_AST_STATIC_CALL:
			zend_compile_var(result, ast, BP_VAR_R);
			return;
		case ZEND_AST_ASSIGN:
			zend_compile_assign(result, ast); //代码走到这里，调用这个函数，下面继续跟进
			return;
		case ZEND_AST_ASSIGN_REF:
			zend_compile_assign_ref(result, ast);
			return;
		case ZEND_AST_NEW:
			zend_compile_new(result, ast);
			return;
		case ZEND_AST_CLONE:
			zend_compile_clone(result, ast);
			return;
		case ZEND_AST_ASSIGN_OP:
			zend_compile_compound_assign(result, ast);
			return;
		case ZEND_AST_BINARY_OP:
			zend_compile_binary_op(result, ast);
			return;
		......
	}
}
``` 
 - 最终上面代码会走到ZEND_AST_ASSIGN的case中，并调用zend_compile_assign(result, ast)函数，继续跟进这个函数：
```c
void zend_compile_assign(znode *result, zend_ast *ast)
{
	zend_ast *var_ast = ast->child[0]; //517的第一个孩子
	zend_ast *expr_ast = ast->child[1]; //517的第二个孩子

	znode var_node, expr_node;
	zend_op *opline;
	uint32_t offset;

	if (is_this_fetch(var_ast)) {
		zend_error_noreturn(E_COMPILE_ERROR, "Cannot re-assign $this");
	}

	zend_ensure_writable_variable(var_ast);

	switch (var_ast->kind) {
		case ZEND_AST_VAR:
		case ZEND_AST_STATIC_PROP:
			offset = zend_delayed_compile_begin(); //初始化zend_stack
			zend_delayed_compile_var(&var_node, var_ast, BP_VAR_W); //处理$a
			zend_compile_expr(&expr_node, expr_ast);//处理1
			zend_delayed_compile_end(offset);
			zend_emit_op(result, ZEND_ASSIGN, &var_node, &expr_node); //生成opline
			return;
		......
		EMPTY_SWITCH_DEFAULT_CASE();
	}
}
```
 - 我们现在进行的是$a = 1的赋值操作，我们根据中间的等号，把它分成两部分：左边的变量部分、右边的表达式部分（这里因为表达式很简单就是1）
 - 现在我们传入的ast是517，它的左子树是256（ZEND_AST_VAR），右子树是64（ZEND_AST_ZVAL）
 - 首先取出它的两个孩子，然后对第一个孩子进行switch，走到ZEND_AST_STATIC_PROP这个case中，执行了5个函数。前两个函数调用先忽略，重点关注第三个zend_compile_expr函数（之前我们调用过它），它是用来处理赋值等号右边的表达式的（传入的参数是517的第二个孩子（即64）），故它目前正在解析$a = 1的右半部分（即上文提到的表达式部分）
 - 会走到zend_compile_expr函数的ZEND_AST_ZVAL这个case，看下这个case：
```c
		case ZEND_AST_ZVAL:
			ZVAL_COPY(&result->u.constant, zend_ast_get_zval(ast));
			result->op_type = IS_CONST;
			return;
```
 - 它调用了一个ZVAL_COPY宏，将这个ZEND_AST_ZVAL类型的结点的zval字段中存储的值（即1对应的zval），拷贝到之前声明的znode类型变量result的u.constant字段中
 - 看一下这个zend_ast_get_zval(ast)的具体实现：
```c
static zend_always_inline zval *zend_ast_get_zval(zend_ast *ast) {
	ZEND_ASSERT(ast->kind == ZEND_AST_ZVAL);
	return &((zend_ast_zval *) ast)->val;
}
```
 - 先忽略断言，它直接利用强转并取出val字段的值，就是1对应的zval，并返回了它的地址
### ZVAL_COPY宏详解
 - 接下来再看一下ZVAL_COPY这个宏，它的功能是把一个zval（v）拷贝到另外一个zval（z）中
 - 我们首先回顾一下zval的结构：
```c
struct _zval_struct {
	zend_value        value;			/* value */
	union {
		struct {
			ZEND_ENDIAN_LOHI_4(
				zend_uchar    type,			/* active type */
				zend_uchar    type_flags,
				zend_uchar    const_flags,
				zend_uchar    reserved)	    /* call info for EX(This) */
		} v;
		uint32_t type_info;
	} u1;
	union {
		uint32_t     next;                 /* hash collision chain */
		uint32_t     cache_slot;           /* literal cache slot */
		uint32_t     lineno;               /* line number (for ast nodes) */
		uint32_t     num_args;             /* arguments number for EX(This) */
		uint32_t     fe_pos;               /* foreach position */
		uint32_t     fe_iter_idx;          /* foreach iterator index */
		uint32_t     access_flags;         /* class constant access flags */
		uint32_t     property_guard;       /* single property guard */
		uint32_t     extra;                /* not further specified */
	} u2;
};
```
 - 由zval结构，我们可以知道：复制zval，就是将老zval中的**value/u1/u2**三个字段拷贝到新zval中即可。
 - 那么，源码中是怎么实现的呢：
```c
#define ZVAL_COPY(z, v)									\
	do {												\
		zval *_z1 = (z);								\
		const zval *_z2 = (v);							\
		zend_refcounted *_gc = Z_COUNTED_P(_z2);		\
		uint32_t _t = Z_TYPE_INFO_P(_z2);				\
		ZVAL_COPY_VALUE_EX(_z1, _z2, _gc, _t);			\
		if ((_t & (IS_TYPE_REFCOUNTED << Z_TYPE_FLAGS_SHIFT)) != 0) { \
			GC_REFCOUNT(_gc)++;							\
		}												\
	} while (0)
```
 - 首先将z赋值给_z1，它是一个地址，然后将v赋值给_z2，也是一个地址，注意这个地址的值是常量，表示不能够修改v指向的zval的值（因为它是被赋值的zval，所以没必要修改它的值）
 - 然后通过Z_COUNTED_P(\_z2)这个宏取出_z2（v）这个zval中的refcounted字段，看下这个宏的具体实现：
```c
#define Z_COUNTED(zval)				(zval).value.counted
#define Z_COUNTED_P(zval_p)			Z_COUNTED(*(zval_p))
```
 - 可以看到，它取出了zval中的zend_value字段中的counted字段的值，那么，为什么要取counted这个字段呢？我们回顾一下zend_value的结构：
```c
typedef union _zend_value {
	zend_long         lval;	//整型
	double            dval;	//浮点
	zend_refcounted  *counted; //引用计数，这里取出这个字段的值
	zend_string      *str; //字符串
	zend_array       *arr; //数组
	zend_object      *obj; //对象
	zend_resource    *res; //资源
	zend_reference   *ref; //引用
	zend_ast_ref     *ast; //抽象语法树
	zval             *zv;  //内部使用
	void             *ptr; //不确定类型，取出来之后强转
	zend_class_entry *ce;  //类
	zend_function    *func;//函数
	struct {
		uint32_t w1;
		uint32_t w2;
	} ww; //这个union一共8B，这个结构体每个字段都是4B，因为所有联合体字段共用一块内存，故相当于取了一半的union
} zend_value;
```
 - 这里一定要注意zend_value是一个**联合体**。由于其内部所有字段共用一块内存空间，源码中取counted字段的值，和取lval/dval/str/arr这些字段值的效果是**完全一样**的，其本质上就是取到了zval中的zend_value这个字段的值。
 - 那么现在我们完成了从老的zval中取到zend_value这个字段的值，还剩下u1/u2两个字段需要我们去拿
 - 接下来它使用了Z_TYPE_INFO_P(\_z2);这个宏，看下它的实现：
```c
#define Z_TYPE_INFO(zval)			(zval).u1.type_info
#define Z_TYPE_INFO_P(zval_p)		Z_TYPE_INFO(*(zval_p))
```
 - 它直接取到了zval中u1的type_info字段。由于u1也是一个联合体，实际上就是取得了v这个结构体中的type/type_flags/const_flags/reserved这四个字段的值，理由同上。这样，u1也拿到了，那么现在还剩下u2没有去取
 - 接下来又去调用了ZVAL_COPY_VALUE_EX(\_z1, \_z2, \_gc, \_t)这个宏，我们看下它的实现：
```c 
# define ZVAL_COPY_VALUE_EX(z, v, gc, t)				\
	do {												\
		Z_COUNTED_P(z) = gc;							\
		Z_TYPE_INFO_P(z) = t;							\
	} while (0)
#else
```
 - 它就是直接将gc(counted字段，即zend_value的值)、以及t(即u1的值)直接拷贝到z这个zval中，这样就完成了zend_value以及u1的复制，那么u2为什么没有拷贝呢？因为u2这个联合体中的字段并不重要，不对其进行复制不会对代码逻辑有任何影响
 - 下面的if我们可以先忽略，由于在ZVAL_COPY_VALUE_EX宏中完成了复制，可以不去考虑下面的逻辑
 - 那么现在针对这个宏中出现的语法，提两个问题：
> 为什么会出现(z)这种语法，不加括号可以吗？
> 为什么要do{}while(0)，反正都是只执行一次这个宏的代码，可以去掉do{}while(0)吗？
 - 针对第一个问题，是出于安全性的考虑，看下面一个例子：
```c
#define X(a, b) \ 
	a = b * 3;
```
 - 如果我们这样调用宏：X(a, 1+2);那么宏展开的结果为 a = 1 + 2 * 3 ，即a = 7 ，而我们预期的结果是a = (1+2) * 3 = 9，出现了运算符优先级的问题，所以当传入的参数是一个表达式的时候，不加括号会出现**运算符优先级**不符合预期的问题，所以加上括号能够更加安全
 - 下面看第二个为什么要加上do-while(0)的问题，扩展一下上面的宏X：
```c
#define X(a, b) \ 
	a = b * 3;
	a  = a + 1;
```
 - 那么我们如果在代码中编写：
```c
if (true)
	X(a, b)
```
 - 那么它的效果等同于：
```c
if (true)
	a = b * 3;
	a = a +1;
```
 - 可以看到，如果if不加{}大括号的话，**只会执行第一条语句a = b * 3*，并不符合预期
 - 如果加上do{}while(0)，其效果等同于：
```c
if (true) 
	do {
		a = b * 3;
		a = a +1;
	} while(0)
```
 - 由于do-while语句的存在，两个表达式变成了**一个整体**，所以宏体中两个表达式都会被执行。所以，这样做能够保证**宏体里所有语句都会被完整的执行**。
## 返回调用处
 - 那么我们回到之前的ZVAL_COPY调用处继续执行，回到zend_compile_assign函数中的ZEND_AST_STATIC_PROP这个case，我们现在的位置是zend_compile_expr(&expr_node, expr_ast);，现在在处理517的第二个孩子（即值1），那么还要处理左边的ZEND_AST_VAR（即$a），那么就是上一行代码中的zend_delayed_compile_var(&var_node, var_ast, BP_VAR_W)函数，它来做这个事情，我们跟进看一下：
```c
void zend_delayed_compile_var(znode *result, zend_ast *ast, uint32_t type) 
{
	zend_op *opline;
	switch (ast->kind) {
		case ZEND_AST_VAR:
			zend_compile_simple_var(result, ast, type, 1);
			return;
	    ...
	}
}
```
 - 它会走到ZEND_AST_VAR这个case中，然后调用zend_compile_simple_var(result, ast, type, 1)，继续跟进：
```c
static void zend_compile_simple_var(znode *result, zend_ast *ast, uint32_t type, int delayed) 
{
	zend_op *opline;

	if (is_this_fetch(ast)) {
		opline = zend_emit_op(result, ZEND_FETCH_THIS, NULL, NULL);
		zend_adjust_for_fetch_type(opline, type);
	} else if (zend_try_compile_cv(result, ast) == FAILURE) {
		zend_op *opline = zend_compile_simple_var_no_cv(result, ast, type, delayed);
		zend_adjust_for_fetch_type(opline, type);
	}
}
```
 - 首先第一个if中is_this_fetch(ast)是判断是否和this（对象）相关，我们这里不是，那么走到下一个else if分支：
 - 调用zend_try_compile_cv(result, ast)函数，这里有一个cv的概念，继续跟进：
```c
static int zend_try_compile_cv(znode *result, zend_ast *ast) 
{
	zend_ast *name_ast = ast->child[0];
	if (name_ast->kind == ZEND_AST_ZVAL) {
		zend_string *name = zval_get_string(zend_ast_get_zval(name_ast));

		if (zend_is_auto_global(name)) {
			zend_string_release(name);
			return FAILURE;
		}

		result->op_type = IS_CV;
		result->u.op.var = lookup_cv(CG(active_op_array), name);

		/* lookup_cv may be using another zend_string instance  */
		name = CG(active_op_array)->vars[EX_VAR_TO_NUM(result->u.op.var)];

		return SUCCESS;
	}

	return FAILURE;
}
```
 - 这个函数首先取它的第一个孩子结点，因为当前传过来的ast是256(ZEND_AST_VAR)，它的孩子结点只有一个且为64，所以第一个if判断为true，调用了 zval_get_string(zend_ast_get_zval(name_ast));
 - 我们由内往外看，首先对这个64的ast结点进行zend_ast_get_zval()函数调用，它会将ZEND_AST类型转化成ZEND_AST_ZVAL类型，和之前在gdb中调试的效果一样
 - 接下来外部对这个ast结点调用zval_get_string()函数，看下它的内部实现：
```c
static zend_always_inline zend_string *_zval_get_string(zval *op) {
	return Z_TYPE_P(op) == IS_STRING ? zend_string_copy(Z_STR_P(op)) : _zval_get_string_func(op);
}
```
 - 首先，Z_TYPE_P这个宏取得zval中的u1.v.type字段，如果是IS_STRING的话，调用zend_string_copy(z_str_p(op))函数，首先调用了Z_STR_P这个宏，它会取得zend_value中的str字段，就是指向zend_string的指针，我们可以看到以下上面宏的定义：
```c
/* we should never set just Z_TYPE, we should set Z_TYPE_INFO */
#define Z_TYPE(zval)				zval_get_type(&(zval))
#define Z_TYPE_P(zval_p)			Z_TYPE(*(zval_p))

static zend_always_inline zend_uchar zval_get_type(const zval* pz) {
	return pz->u1.v.type;
}

...
#define Z_STR(zval)					(zval).value.str
#define Z_STR_P(zval_p)				Z_STR(*(zval_p))
```
 - 我们继续看一下外层zend_string_copy()的实现：
```c
static zend_always_inline zend_string *zend_string_copy(zend_string *s)
{
	if (!ZSTR_IS_INTERNED(s)) {
		GC_REFCOUNT(s)++;
	}
	return s;
}
```
 - 我们看到仅仅是做了一个对zend_string中的refcount字段++的操作，并没有真正去做copy（和之前zval真正的copy不同） 
 - 回到zend_try_compile_cv()这个函数，我们在调用完之后将结果赋值给name变量。接下来因为变量不是全局的，所以不进这个if。接下来对result变量的两个字段进行了赋值操作：
```c
result->op_type = IS_CV;
result->u.op.var = lookup_cv(CG(active_op_array), name);
```
 - 首先为它赋值IS_CV。那么什么是CV型变量呢？CV，即compiled variable，是PHP编译过程中产生的一种变量类型，以类似于缓存的方式，提高某些变量的存储速度。这里$a = 1中的$a，就是CV型变量。
 - 第二行，给result中的u.op.var字段赋值，而result我们讲过，是一个znode。重点关注右边lookup_cv()函数，它会去op_array(很重要，后面会讲)中是否有之前解析过的变量，这样就不用去做二次解析了。这里先不对lookup_cv()这个函数展开。
 - 那么至此，运算符ASSIGN(=)、结果result($a)、操作数1（op1）三要素都已经解析完毕，就可以生成最终的指令集了。